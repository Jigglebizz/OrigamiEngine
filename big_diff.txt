diff --git a/Kami/AssetDb.cpp b/Kami/AssetDb.cpp
index 3fcdc4d..482efaf 100644
--- a/Kami/AssetDb.cpp
+++ b/Kami/AssetDb.cpp
@@ -5,22 +5,24 @@
 #include "Origami/Util/Search.h"
 
 static const     char*    kAssetDbFilename    = "AssetDb.db";
-static constexpr uint16_t kCapacityIncrements = 1024;
+static constexpr uint32_t kCapacityIncrements = 1024;
 
 //---------------------------------------------------------------------------------
 void AssetDb::Init()
 {
   m_Mutex.Init( "Asset DB" );
   snprintf( m_FilePath, sizeof( m_FilePath ), "%s\\%s", Filesystem::GetAssetsBuiltPath(), kAssetDbFilename );
+  m_Heap.InitWithBacking( m_HeapBacking, sizeof( m_HeapBacking ), "AssetDB Heap" );
+
   m_EntriesCapacity = kCapacityIncrements;
   m_EntriesCount    = 0;
-  m_Entries = (AssetDbEntry*)malloc( m_EntriesCapacity );
+  m_Entries = (AssetDbEntry*)m_Heap.Alloc( m_EntriesCapacity );
 }
 
 //---------------------------------------------------------------------------------
 void AssetDb::Destroy()
 {
-  free( m_Entries );
+  m_Heap.Free( m_Entries );
   m_Mutex.Destroy();
 }
 
@@ -45,9 +47,9 @@ AssetDb::LoadStatus AssetDb::LoadFromDisk()
 
       m_EntriesCapacity = ( ( m_EntriesCount / kCapacityIncrements) + 1 ) * kCapacityIncrements;
 
-      free( m_Entries );
+      m_Heap.Free( m_Entries );
 
-      m_Entries = (AssetDbEntry*)malloc( m_EntriesCapacity );
+      m_Entries = (AssetDbEntry*)m_Heap.Alloc( m_EntriesCapacity );
       return kLoadStatusOk;
     }
     printf( "Error! could not open db file: %d", err );
@@ -94,7 +96,7 @@ void AssetDb::UpdateEntries( AssetId* ids, uint32_t* versions, uint32_t len )
     {
       if ( m_EntriesCount == m_EntriesCapacity )
       {
-        AssetDbEntry* new_entries = (AssetDbEntry*)realloc( m_Entries, m_EntriesCapacity + kCapacityIncrements );
+        AssetDbEntry* new_entries = (AssetDbEntry*)m_Heap.Realloc( m_Entries, (uint64_t)m_EntriesCapacity + (uint64_t)kCapacityIncrements );
         if ( new_entries == nullptr )
         {
           printf("Error! could not realloc asset db!\n");
diff --git a/Kami/AssetDb.h b/Kami/AssetDb.h
index 441477f..444c13b 100644
--- a/Kami/AssetDb.h
+++ b/Kami/AssetDb.h
@@ -14,12 +14,17 @@ struct AssetDbEntry
 //---------------------------------------------------------------------------------
 class AssetDb
 {
+  static constexpr size_t kHeapSize = 1024 * 1024 * 1024; // 1 GB ought to do it.
+
   uint32_t      m_EntriesCount;
   uint32_t      m_EntriesCapacity;
   AssetDbEntry* m_Entries;
   char          m_FilePath[ Filesystem::kMaxPathLen ];
   mutable Mutex m_Mutex;
 
+  char          m_HeapBacking[ kHeapSize ];
+  MemAllocHeap  m_Heap;
+
 public:
   enum LoadStatus : uint8_t
   {
diff --git a/Kami/main.cpp b/Kami/main.cpp
index 8207546..dc3611b 100644
--- a/Kami/main.cpp
+++ b/Kami/main.cpp
@@ -14,10 +14,16 @@
 static constexpr uint32_t kMaxBuildersCount = 32;
 static constexpr uint8_t  kMaxExtensionLen  = 16;
 
+static constexpr uint32_t kKamiWorkingSetSize = 20 * 1024 * 1024; // 20 MB
+
 //---------------------------------------------------------------------------------
 char g_SourcePath      [ Filesystem::kMaxPathLen ];
 char g_BuildersDirPath [ Filesystem::kMaxPathLen ];
 
+//---------------------------------------------------------------------------------
+char         g_KamiWorkingSetBacking[ kKamiWorkingSetSize ];
+MemAllocHeap g_KamiWorkingSetHeap;
+
 //---------------------------------------------------------------------------------
 AssetDb g_AssetDb;
 Thread  g_AssetDbPersistenceThread;
@@ -114,14 +120,14 @@ void GetOutOfDateBuiltAssets()
   uint32_t asset_db_size = g_AssetDb.GetCapacity();
   g_AssetChangesCapacity = ( asset_db_size > 0 ) ? asset_db_size : 1024;
 
-  g_AssetChanges         = (AssetChangeInfo*)malloc( g_AssetChangesCapacity * sizeof( AssetChangeInfo ) );
+  g_AssetChanges         = (AssetChangeInfo*)g_KamiWorkingSetHeap.Alloc( g_AssetChangesCapacity * sizeof( AssetChangeInfo ) );
   g_AssetChangeCount     = 0;
 
   // scan db for builder version differences
   uint32_t  num_changed_ids   = g_AssetChangesCapacity;
-  AssetId*  changed_asset_ids = (AssetId*)malloc( num_changed_ids * sizeof( AssetId ) );
+  AssetId*  changed_asset_ids = (AssetId*)g_KamiWorkingSetHeap.Alloc( num_changed_ids * sizeof( AssetId ) );
 
-  uint32_t* current_asset_versions = (uint32_t*)malloc( g_BuilderCount * sizeof ( uint32_t ) );
+  uint32_t* current_asset_versions = (uint32_t*)g_KamiWorkingSetHeap.Alloc( g_BuilderCount * sizeof ( uint32_t ) );
   if ( current_asset_versions == nullptr )
   {
     printf( "Could not allocate memory for current_asset_versions!\n");
@@ -140,7 +146,7 @@ void GetOutOfDateBuiltAssets()
 //---------------------------------------------------------------------------------
 void ScanFilesystemForNewAssets()
 {
-  uint32_t* asset_extensions = (uint32_t*)malloc( sizeof(uint32_t) * g_BuilderCount );
+  uint32_t* asset_extensions = (uint32_t*)g_KamiWorkingSetHeap.Alloc( sizeof(uint32_t) * g_BuilderCount );
 
 
   Filesystem::DoForEachFileInDirectory( Filesystem::GetAssetsSourcePath(), [ asset_extensions ]( const Filesystem::FileCallbackParams* file_params ) {
@@ -174,6 +180,8 @@ int main( int argc, char* argv[] )
     Filesystem::CreateDir( Filesystem::GetAssetsBuiltPath() );
   }
 
+  g_KamiWorkingSetHeap.InitWithBacking( g_KamiWorkingSetBacking, sizeof( g_KamiWorkingSetBacking ), "Kami Working Set" );
+
   snprintf( g_BuildersDirPath, sizeof( g_BuildersDirPath ), "%s\\%s\\%s\\Builders", Filesystem::GetOutputPath(), BUILD_PLATFORM, BUILD_CONFIG );
   LoadBuilderInfos();
   g_AssetDb.Init();
diff --git a/Origami/Actor/Actor.cpp b/Origami/Actor/Actor.cpp
index 505fe31..3ad9faa 100644
--- a/Origami/Actor/Actor.cpp
+++ b/Origami/Actor/Actor.cpp
@@ -17,8 +17,7 @@ void ActorBase::BaseDestroy( )
 {
   for ( uint32_t i_component = 0; i_component < m_ComponentCount; ++i_component )
   {
-    // TODO: Use component heap
-    delete m_Components[ i_component ].m_Component;
+    Actor::g_ActorCon.m_ComponentHeap.Free( m_Components[ i_component ].m_Component );
   }
 }
 
diff --git a/Origami/Actor/Actor.h b/Origami/Actor/Actor.h
index 22ca04d..f3422a3 100644
--- a/Origami/Actor/Actor.h
+++ b/Origami/Actor/Actor.h
@@ -2,6 +2,7 @@
 
 #include "Origami/Math/Primitives.h"
 #include "Origami/Actor/BaseComponent.h"
+#include "Origami/Actor/ActorSystem.h"
 
 #include "Origami/Util/Search.h"
 #include "Origami/Util/Sort.h"
@@ -34,17 +35,17 @@ protected:
           void     BaseDestroy ();
 public:
   //---------------------------------------------------------------------------------
-  const   char*    GetName     () const;
-  inline  uint64_t GetId       () const;
-
-  virtual void     Init        ( );
-          void     UpdateFirst ( float dt );
-          void     UpdateMiddle( float dt );
-          void     UpdateLast  ( float dt );
-  virtual void     Destroy     ();
+  const   char*    ENGINE_API GetName     () const;
+  inline  uint64_t ENGINE_API GetId       () const;
+
+  virtual void     ENGINE_API Init        ( );
+          void     ENGINE_API UpdateFirst ( float dt );
+          void     ENGINE_API UpdateMiddle( float dt );
+          void     ENGINE_API UpdateLast  ( float dt );
+  virtual void     ENGINE_API Destroy     ();
                    
-  inline  Vec2     GetPosition () const;
-  inline  void     SetPosition ( const Vec2* pos );
+  inline  Vec2     ENGINE_API GetPosition () const;
+  inline  void     ENGINE_API SetPosition ( const Vec2* pos );
 
   template <class ComponentClass>
   void ENGINE_API AddComponent( void* init_params = nullptr );
@@ -72,7 +73,8 @@ uint64_t ActorBase::GetId() const
 template <class ComponentClass>
 void ActorBase::AddComponent( void* init_params )
 {
-  // TODO: Create on component heap
+  Actor::ActorCon* con = &Actor::g_ActorCon;
+
   ASSERT_MSG( m_ComponentCount < kMaxComponents, "Attempting to add too many components to actor!" );
   uint64_t id = ComponentClass::GetId();
 
@@ -82,8 +84,7 @@ void ActorBase::AddComponent( void* init_params )
   ComponentInfo* new_info = &m_Components[ m_ComponentCount++ ];
   new_info->m_ComponentTypeId = id;
 
-  // TODO: create from component heap
-  new_info->m_Component = new ComponentClass();
+  new_info->m_Component = (ComponentClass*)con->m_ComponentHeap.Alloc( sizeof( ComponentClass ) );
   new_info->m_Component->Init( this, init_params );
 
   QuickSort64( m_Components, sizeof( ComponentInfo ), m_ComponentCount );
diff --git a/Origami/Actor/ActorSystem.cpp b/Origami/Actor/ActorSystem.cpp
index d59ab56..5c2ef81 100644
--- a/Origami/Actor/ActorSystem.cpp
+++ b/Origami/Actor/ActorSystem.cpp
@@ -1,50 +1,86 @@
 #include "Origami/pch.h"
 #include "Origami/Actor/ActorSystem.h"
 
+#include "Origami/Actor/Actor.h"
+#include "Origami/Util/Log.h"
+
 //---------------------------------------------------------------------------------
 void Actor::Init()
 {
-  s_ActorInfoCount = 0;
-  MemZero( &s_ActorInfos, sizeof( s_ActorInfos ) );
+  ActorCon* con = &g_ActorCon;
+
+  con->m_ActorInfoCount = 0;
+  MemZero( &con->m_ActorInfos, sizeof( con->m_ActorInfos ) );
+
+  con->m_ComponentHeap.InitWithBacking( con->m_ComponentHeapBacking, sizeof( con->m_ComponentHeapBacking ), "Component Heap" );
+  Log::LogInfo("Component heap contains: \n");
+
+  char heap_bytes_str[ sizeof( con->m_ComponentHeap ) * 4 ];
+  uint32_t offset = 0;
+  heap_bytes_str[ offset++ ] = '\n';
+
+  for ( uint32_t i_byte = 0; i_byte < sizeof( con->m_ComponentHeap ); ++i_byte )
+  {
+    char current_char = *((char*)&con->m_ComponentHeap + i_byte);
+
+    snprintf( heap_bytes_str + offset, sizeof( heap_bytes_str ), " %02X", current_char );
+    offset += 3;
+
+    if ( ( i_byte + 1 ) % 8 == 0 && i_byte != sizeof( con->m_ComponentHeap) -1 )
+    {
+      heap_bytes_str[ offset ] = '\n';
+      offset++;
+    }
+  }
+
+  Log::LogInfo( "%s", heap_bytes_str );
+}
+
+//---------------------------------------------------------------------------------
+void Actor::Destroy()
+{
+  g_ActorCon.m_ComponentHeap.Destroy();
 }
 
 //---------------------------------------------------------------------------------
 void Actor::UpdateFirst( float dt )
 {
-  for ( uint32_t i_actor = 0; i_actor < s_ActorInfoCount; ++i_actor )
+  for ( uint32_t i_actor = 0; i_actor < g_ActorCon.m_ActorInfoCount; ++i_actor )
   {
-    s_ActorInfos[ i_actor ].m_Actor->UpdateFirst( dt );
+    g_ActorCon.m_ActorInfos[ i_actor ].m_Actor->UpdateFirst( dt );
   }
 }
 
 //---------------------------------------------------------------------------------
 void Actor::UpdateMiddle( float dt )
 {
-  for ( uint32_t i_actor = 0; i_actor < s_ActorInfoCount; ++i_actor )
+  for ( uint32_t i_actor = 0; i_actor < g_ActorCon.m_ActorInfoCount; ++i_actor )
   {
-    s_ActorInfos[ i_actor ].m_Actor->UpdateMiddle( dt );
+    g_ActorCon.m_ActorInfos[ i_actor ].m_Actor->UpdateMiddle( dt );
   }
 }
 
 //---------------------------------------------------------------------------------
 void Actor::UpdateLast( float dt )
 {
-  for ( uint32_t i_actor = 0; i_actor < s_ActorInfoCount; ++i_actor )
+  for ( uint32_t i_actor = 0; i_actor < g_ActorCon.m_ActorInfoCount; ++i_actor )
   {
-    s_ActorInfos[ i_actor ].m_Actor->UpdateLast( dt );
+    g_ActorCon.m_ActorInfos[ i_actor ].m_Actor->UpdateLast( dt );
   }
 }
 
 //---------------------------------------------------------------------------------
 void Actor::AddActor( ActorBase* actor )
 {
-  ASSERT_MSG( s_ActorInfoCount < kMaxActors, "Attempting to add too many actors!" );
+  ActorCon* con = &g_ActorCon;
+
+  ASSERT_MSG( con->m_ActorInfoCount < kMaxActors, "Attempting to add too many actors!" );
 
-  ActorInfo* actor_info = &s_ActorInfos[ s_ActorInfoCount++ ];
+  ActorInfo* actor_info = &con->m_ActorInfos[ con->m_ActorInfoCount++ ];
   actor_info->m_Actor = actor;
   actor_info->m_ActorId = actor->GetId();
 
-  QuickSort64( s_ActorInfos, sizeof( ActorInfo ), s_ActorInfoCount );
+  QuickSort64( con->m_ActorInfos, sizeof( ActorInfo ), con->m_ActorInfoCount );
 
   actor_info->m_Actor->Init(); // TODO: move to system's loop?
 }
\ No newline at end of file
diff --git a/Origami/Actor/ActorSystem.h b/Origami/Actor/ActorSystem.h
index d012471..7651050 100644
--- a/Origami/Actor/ActorSystem.h
+++ b/Origami/Actor/ActorSystem.h
@@ -1,11 +1,15 @@
 #pragma once
 
-#include "Origami/Actor/Actor.h"
+class ActorBase;
 
 namespace Actor
 {
+  //---------------------------------------------------------------------------------
+  static constexpr uint32_t kComponentHeapSize = 32 * 1024 * 1024; // 32 MB
+
   //---------------------------------------------------------------------------------
   void            Init();
+  void            Destroy();
   void            UpdateFirst  ( float dt );
   void            UpdateMiddle ( float dt );
   void            UpdateLast   ( float dt );
@@ -21,6 +25,14 @@ namespace Actor
     ActorBase* m_Actor;
   };
 
-  static uint32_t     s_ActorInfoCount;
-  static ActorInfo    s_ActorInfos[ kMaxActors ];
+  struct ActorCon
+  {
+    char         m_ComponentHeapBacking[ kComponentHeapSize ];
+    MemAllocHeap m_ComponentHeap;
+
+    uint32_t     m_ActorInfoCount;
+    ActorInfo    m_ActorInfos[ kMaxActors ];
+  };
+
+  static ActorCon g_ActorCon;
 }
\ No newline at end of file
diff --git a/Origami/Asset/AssetLoader.cpp b/Origami/Asset/AssetLoader.cpp
index 8a9eaa9..2452f8e 100644
--- a/Origami/Asset/AssetLoader.cpp
+++ b/Origami/Asset/AssetLoader.cpp
@@ -7,6 +7,18 @@
 #include "Origami/Util/Log.h"
 
 
+//---------------------------------------------------------------------------------
+void AssetLoader::Init()
+{
+  m_AssetHeap.InitWithBacking( m_AssetHeapBacking, sizeof( m_AssetHeapBacking ), "Asset Heap" );
+}
+
+//---------------------------------------------------------------------------------
+void AssetLoader::Destroy()
+{
+  m_AssetHeap.Destroy();
+}
+
 //---------------------------------------------------------------------------------
 char* AssetLoader::Load( const char* asset_name )
 {
@@ -23,7 +35,7 @@ char* AssetLoader::Load( const char* asset_name )
   uint64_t asset_size = file.tellg();
   file.seekg( 0, std::ios::beg );
 
-  BasicAsset* asset = (BasicAsset*)malloc( sizeof( BasicAsset ) + asset_size );
+  BasicAsset* asset = (BasicAsset*)m_AssetHeap.Alloc( sizeof( BasicAsset ) + asset_size );
 
   if ( asset == nullptr )
   {
@@ -42,5 +54,5 @@ char* AssetLoader::Load( const char* asset_name )
 //---------------------------------------------------------------------------------
 void AssetLoader::Free( void* asset )
 {
-  free( asset );
+  m_AssetHeap.Free( asset );
 }
\ No newline at end of file
diff --git a/Origami/Asset/AssetLoader.h b/Origami/Asset/AssetLoader.h
index 4a37c36..685fc68 100644
--- a/Origami/Asset/AssetLoader.h
+++ b/Origami/Asset/AssetLoader.h
@@ -4,6 +4,10 @@
 
 namespace AssetLoader
 {
+  static constexpr uint32_t kAssetHeapSize = 512 * 1024 * 1024; // 1GB of loaded assets
+
+  static char         m_AssetHeapBacking[ kAssetHeapSize ];
+  static MemAllocHeap m_AssetHeap;
 
   struct BasicAsset
   {
@@ -13,6 +17,9 @@ namespace AssetLoader
   };
  
   //---------------------------------------------------------------------------------
+  void  Init();
+  void  Destroy();
+
   char* Load( const char* asset_path );
   void  Free( void* asset );
 }
\ No newline at end of file
diff --git a/Origami/Game/Game.cpp b/Origami/Game/Game.cpp
index 54f4acf..a23cd01 100644
--- a/Origami/Game/Game.cpp
+++ b/Origami/Game/Game.cpp
@@ -29,6 +29,7 @@ void LogFunction( uint8_t flags, const char* fmt, va_list args )
 void Game::Init( const char* title, const char* window_icon )
 {
   Log::RegisterCallback(LogFunction);
+  AssetLoader::Init();
   Actor::Init();
   Render::Init( title, window_icon );
   Anim::Init();
@@ -61,6 +62,7 @@ void Destroy()
 {
   Anim::Destroy();
   Render::Destroy();
+  AssetLoader::Destroy();
 }
 
 //---------------------------------------------------------------------------------
diff --git a/Origami/Memory/Memory.cpp b/Origami/Memory/Memory.cpp
index 083acd7..6936ac4 100644
--- a/Origami/Memory/Memory.cpp
+++ b/Origami/Memory/Memory.cpp
@@ -1,6 +1,11 @@
 #include "Origami/pch.h"
 #include "Origami/Memory/Memory.h"
 
+#include "Origami/Util/Log.h"
+
+#define MEMORY_LOGGING
+DISABLE_OPTS
+
 //---------------------------------------------------------------------------------
 void MemZero( void* dst, size_t n )
 {
@@ -112,48 +117,64 @@ uint32_t Bitset::GetNextSetBit( uint32_t current ) const
 }
 
 //---------------------------------------------------------------------------------
-void MemAllocHeap::InitWithBacking( void* data, size_t size, char* name )
+void MemAllocHeap::InitWithBacking( void* data, size_t size, const char* name )
 {
   ASSERT_MSG( StrLen( name ) <= kMaxHeapNameSize, "Heap name is too long" );
+  strcpy_s( m_HeapName, name );
 
-  m_Tlsf = tlsf_create_with_pool( data, size );
+  //m_Tlsf = tlsf_create_with_pool( data, size );
+
+#ifdef MEMORY_LOGGING
+  Log::LogInfo( "Created TLSF heap %s of size %llu. Data is at %#08x\n", name, size, data );
+#endif
 }
 
 //---------------------------------------------------------------------------------
 void MemAllocHeap::Destroy()
 {
-  tlsf_destroy( m_Tlsf );
+  //tlsf_destroy( m_Tlsf );
+
+#ifdef MEMORY_LOGGING
+  Log::LogInfo("Destroyed TLSF heap %s\n", m_HeapName );
+#endif
 }
 
 //---------------------------------------------------------------------------------
 void* MemAllocHeap::Alloc( size_t size )
 {
-  return tlsf_malloc( m_Tlsf, size );
+  return malloc( size );
+  //return tlsf_malloc( m_Tlsf, size );
 }
 
 //---------------------------------------------------------------------------------
 void* MemAllocHeap::MemAlign( size_t align, size_t bytes )
 {
-  return tlsf_memalign( m_Tlsf, align, bytes );
+  UNREFFED_PARAMETER( align );
+  UNREFFED_PARAMETER( bytes );
+  return nullptr;
+  //return tlsf_memalign( m_Tlsf, align, bytes );
 }
 
 //---------------------------------------------------------------------------------
 void* MemAllocHeap::Realloc( void* ptr, size_t size )
 {
-  return tlsf_realloc( m_Tlsf, ptr, size );
+  return realloc( ptr, size );
+  //return tlsf_realloc( m_Tlsf, ptr, size );
 }
 
 //---------------------------------------------------------------------------------
 void MemAllocHeap::Free( void* ptr )
 {
-  tlsf_free( m_Tlsf, ptr );
+  return free( ptr );
+  //tlsf_free( m_Tlsf, ptr );
 }
 
 //---------------------------------------------------------------------------------
 HeapAuditInfo MemAllocHeap::Audit()
 {
   HeapAuditInfo info;
-  info.size = tlsf_size();
+  info.size = 1'000'000'000;
+  //info.size = tlsf_size();
 
   return info;
 }
\ No newline at end of file
diff --git a/Origami/Memory/Memory.h b/Origami/Memory/Memory.h
index feee174..df8c7a1 100644
--- a/Origami/Memory/Memory.h
+++ b/Origami/Memory/Memory.h
@@ -52,12 +52,12 @@ struct HeapAuditInfo
 class MemAllocHeap
 {
 private:
+public:
   static constexpr uint32_t kMaxHeapNameSize = 32;
 
-  const char m_HeapName[ kMaxHeapNameSize ];
-  tlsf_t     m_Tlsf;
-public:
-  void          ENGINE_API InitWithBacking ( void* data, size_t size, char* name );
+  tlsf_t m_Tlsf;
+  char   m_HeapName[ kMaxHeapNameSize ];
+  void          ENGINE_API InitWithBacking ( void* data, size_t size, const char* name );
   void          ENGINE_API Destroy         ();
 
   void*         ENGINE_API Alloc           ( size_t size );
